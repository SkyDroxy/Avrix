import org.gradle.internal.os.OperatingSystem

/**
 * Gradle plugins
 */
plugins {
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'java'
}

/**
 * Project Variables
 */
group = 'com.avrix'
// Allow CI to override version via env (e.g., AVRIX_VERSION or GITHUB_REF_NAME)
def envVer = System.getenv('AVRIX_VERSION') ?: System.getenv('GITHUB_REF_NAME')
if (envVer != null && !envVer.isEmpty()) {
    // Strip leading v/V from tag names like v1.2.3
    version = envVer.replaceFirst(/^[vV]/, '')
} else {
    version = '1.7.3'
}

/**
 * Path to the compiled Jar file
 */
def buildPath = System.getenv('BUILD_PATH') ?: 'build';
def baseArchiveName = "${rootProject.name.capitalize()}-Core";

/**
 * Repositories for project dependencies
 */
repositories {
    mavenCentral()
    flatDir {
        dirs project.file("$rootProject.projectDir/libs")
    }
    maven {
        name = "henkelmax.public"
        url = 'https://maven.maxhenkel.de/repository/public'
    }
}

/**
 * LWJGL switch natives
 */
switch (OperatingSystem.current()) {
    case OperatingSystem.LINUX:
        project.ext.lwjglNatives = "natives-linux"
        def osArch = System.getProperty("os.arch")
        if (osArch.startsWith("arm") || osArch.startsWith("aarch64")) {
            project.ext.lwjglNatives += osArch.contains("64") || osArch.startsWith("armv8") ? "-arm64" : "-arm32"
        } else if (osArch.startsWith("ppc")) {
            project.ext.lwjglNatives += "-ppc64le"
        } else if (osArch.startsWith("riscv")) {
            project.ext.lwjglNatives += "-riscv64"
        }
        break
    case OperatingSystem.MAC_OS:
        project.ext.lwjglNatives = "natives-macos"
        break
    case OperatingSystem.WINDOWS:
        def osArch = System.getProperty("os.arch")
        project.ext.lwjglNatives = osArch.contains("64")
                ? "natives-windows${osArch.startsWith("aarch64") ? "-arm64" : ""}"
                : "natives-windows-x86"
        break
}

/**
 * Project Dependencies
 */
dependencies {
    /**
     * Project Zomboid
     * Dependencies are created via the Gradle task 'createZombieJar'
     */
    compileOnly files('libs/ProjectZomboid-core-41.78.16.jar')
    compileOnly files('libs/ProjectZomboid-libs-41.78.16.jar')

    /**
     * Utils
     */
    implementation('org.yaml:snakeyaml:2.2')
    implementation('org.javassist:javassist:3.30.2-GA')
    implementation('org.tinylog:tinylog-api:2.7.0')
    implementation('org.tinylog:tinylog-impl:2.7.0')
    implementation 'org.json:json:20240303'
    testImplementation 'org.json:json:20240303'

    implementation platform("org.lwjgl:lwjgl-bom:3.3.6")

    // Core LWJGL
    implementation "org.lwjgl:lwjgl"
    runtimeOnly "org.lwjgl:lwjgl::$lwjglNatives"
    
    // glfw
    implementation "org.lwjgl:lwjgl-glfw"
    runtimeOnly "org.lwjgl:lwjgl-glfw::$lwjglNatives"

    // NanoVG
    implementation "org.lwjgl:lwjgl-nanovg"
    runtimeOnly "org.lwjgl:lwjgl-nanovg::$lwjglNatives"    

    /**
     * Test
     */
    testImplementation platform('org.junit:junit-bom:5.10.0')
    testImplementation('org.junit.jupiter:junit-jupiter')
}

/**
 * Project testing
 */
test {
    dependsOn shadowJar
    classpath = project.sourceSets.test.output + configurations.testRuntimeClasspath + files("${buildPath}/${rootProject.name}-Core-${version}.jar")
    jvmArgs '-Djdk.attach.allowAttachSelf=true'
    useJUnitPlatform()
}

/**
 * Configures the source sets for the project.
 */
sourceSets {
    main {
        resources {
            srcDir 'src/main/resources'
        }
    }
    test {
        resources {
            srcDir 'src/test/resources'
        }
    }
}

/**
 * Configures the processTestResources task to handle duplicate resources.
 */
processTestResources {
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

/**
 * Replacing data with current ones
 */
processResources {
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
    filesMatching('**/avrix.properties') {
        filter {
            it.replace('%PROJECT_VERSION%', version)
                    .replace('%PROJECT_NAME%', rootProject.name.capitalize() + " Loader")
        }
    }
    // Replace version token inside core metadata.yml (root resource)
    filesMatching('metadata.yml') {
        filter { line -> line.replace('%PROJECT_VERSION%', version) }
    }
    // Replace version token inside internal plugin metadata (avrix-loader)
    filesMatching('internal-plugins/avrix-loader.yml') {
        filter { line -> line.replace('%PROJECT_VERSION%', version) }
    }
    // Replace version token for pz-core (derive from libs jar filename or fallback)
    def pzVersion = '41.78.16'
    def coreJar = file('libs/ProjectZomboid-core-41.78.16.jar')
    if (coreJar.exists()) {
        def m = (coreJar.name =~ /core-(\d+\.\d+\.\d+)\.jar$/)
        if (m.find()) {
            pzVersion = m.group(1)
        }
    }
    filesMatching('internal-plugins/pz-core.yml') {
        def finalPz = pzVersion
        filter { line -> line.replace('%PZ_CORE_VERSION%', finalPz) }
    }
}

// Ensure resource filtering uses UTF-8 to keep accents correct in metadata.yml & internal plugins
tasks.withType(ProcessResources).configureEach {
    filteringCharset = 'UTF-8'
}

/**
 * Creating a Jar file wrapper (core) to run a game server
 */
shadowJar {
    archiveBaseName.set(baseArchiveName)
    archiveClassifier.set('')

    destinationDirectory.set(file(buildPath))

    manifest {
        attributes(
                'Implementation-Title': rootProject.name.capitalize(),
                'Implementation-Version': version,
                'Agent-Class': 'com.avrix.agent.Agent',
                'Can-Redefine-Classes': 'true',
                'Can-Retransform-Classes': 'true'
        )
    }
}

/**
 * Building a release Jars archive with documentation and sources
 */
tasks.register('releaseBuildJar') {
    dependsOn javadocJar, sourceJar
    finalizedBy buildJar
}

/**
 * Building a Jar archive with documentation
 */
tasks.register('buildJar') {
    finalizedBy shadowJar
}

/**
 * Creating javadoc in jar archive
 */
tasks.register('javadocJar', Jar) {
    dependsOn(tasks.generateJavaDoc)
    archiveBaseName.set(baseArchiveName)
    archiveClassifier.set('javadoc')
    from(file("docs/javadoc"))
    destinationDirectory.set(file(buildPath))
}

/**
 * Packaging source code in a Jar archive
 */
tasks.register('sourceJar', Jar) {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    archiveBaseName.set(baseArchiveName)
    archiveClassifier.set('sources')
    from(sourceSets.main.allSource)
    destinationDirectory.set(file(buildPath))
}

/**
 * Generating Jar Files of Project Zomboid File Dependencies
 * Required environment variables:
 * 1) ZOMBIE_FOLDER_PATH (For example: C:\Steam\steamapps\common\Project Zomboid Dedicated Server\java\zombie)
 * 2) GAME_FOLDER_PATH (For example: C:\Steam\steamapps\common\Project Zomboid Dedicated Server\java)
 */
tasks.register('buildZomboidDependencies') {
    dependsOn createZombieLibsJar, createZombieJar
}

/**
 * Generating JavaDoc for Jar archive
 */
tasks.register('generateJavaDoc', Javadoc) {
    source = sourceSets.main.allJava
    classpath = sourceSets.main.compileClasspath
    destinationDir = file("docs/javadoc")
    options {
        encoding = 'UTF-8'
        charSet = 'UTF-8'
        links("https://docs.oracle.com/en/java/javase/17/docs/api/")
        memberLevel = JavadocMemberLevel.PUBLIC
    }
}

/**
 * Task for creating a JAR file named 'ProjectZomboid-core-41.78.16.jar' from the contents of a specified folder.
 * For example ZOMBIE_FOLDER_PATH: C:\Steam\steamapps\common\Project Zomboid Dedicated Server\java\zombie
 */
tasks.register('createZombieJar') {
    doLast {
        def zombieFolderPath = System.getenv("ZOMBIE_FOLDER_PATH")
        def archiveName = 'ProjectZomboid-core-41.78.16.jar'

        if (zombieFolderPath == null || zombieFolderPath.isEmpty()) {
            println "Error: The ZOMBIE_FOLDER_PATH environment variable is not set or is empty."
            throw new GradleException("ZOMBIE_FOLDER_PATH is required for createZombieJar.")
        }

        def tempDir = file('tempDir')
        def tempDirZombie = file('tempDir/zombie')
        tempDir.mkdirs()

        copy {
            from zombieFolderPath
            into tempDirZombie
        }

        // Check for .class files before creating the JAR
        def classFiles = fileTree(tempDir) {
            include '**/*.class'
        }
        if (classFiles.isEmpty()) {
            println "Error: No .class files found in ${zombieFolderPath}. Please check the path and make sure it contains compiled Java classes."
            delete tempDir
            throw new GradleException("No .class files found, JAR creation aborted.")
        }

        exec {
            commandLine 'jar', 'cvf', archiveName, '-C', tempDir, '.'
        }

        def libsFolder = file('libs')
        libsFolder.mkdirs()
        def targetFile = file("${libsFolder}/${archiveName}")
        if (targetFile.exists()) {
            targetFile.delete()
        }
        file(archiveName).renameTo(targetFile)

        delete tempDir
    }
}

/**
 * Task for creating a JAR file named 'ProjectZomboid-libs-41.78.16.jar' from the contents of a specified folder.
 * For example GAME_FOLDER_PATH: C:\Steam\steamapps\common\Project Zomboid Dedicated Server\java
 */
tasks.register('createZombieLibsJar') {
    doLast {
        def gameFolderPath = System.getenv('GAME_FOLDER_PATH')
        def archiveName = 'ProjectZomboid-libs-41.78.16.jar'

        if (gameFolderPath == null || gameFolderPath.isEmpty()) {
            println('Error: The GAME_FOLDER_PATH environment variable is not set or is empty.')
            throw new GradleException("GAME_FOLDER_PATH is required for createZombieLibsJar.")
        }

        def tempDir = file('temps')
        tempDir.mkdirs()

        def jarFiles = file(gameFolderPath).listFiles().findAll { it.isFile() && it.name.endsWith('.jar') && !it.name.contains(rootProject.name) }

        def excludedFolders = ['zombie', 'jre', 'jre64', 'launcher', 'media',
                               'license', 'mods', 'win32', 'win64', 'workshop']
        def includedFolders = file(gameFolderPath).listFiles().findAll { it.isDirectory() && !excludedFolders.contains(it.name.toLowerCase()) }

        includedFolders.each { dir ->
            copy {
                from dir
                into file("${tempDir}/${dir.name}")
            }
        }

        jarFiles.each { jarFile ->
            copy {
                from jarFile
                into tempDir
            }
        }

        def tempJarFiles = tempDir.listFiles().findAll { it.isFile() && it.name.endsWith('.jar') }

        tempJarFiles.each { jarFile ->
            exec {
                workingDir tempDir
                commandLine 'jar', 'xf', jarFile.absolutePath
            }
            jarFile.delete()
        }

        exec {
            commandLine 'jar', 'cvf', archiveName, '-C', tempDir, '.'
        }

        def libsFolder = file('libs')
        libsFolder.mkdirs()
        def targetFile = file("${libsFolder}/${archiveName}")
        if (targetFile.exists()) {
            targetFile.delete()
        }
        file(archiveName).renameTo(file("${libsFolder}/${archiveName}"))

        delete tempDir
    }
}